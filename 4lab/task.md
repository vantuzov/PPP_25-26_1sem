### Лабораторная №4: Полиморфизм

Тема: «Общий интерфейс и наследование для разнородных данных».

Нужно спроектировать и реализовать систему классов, в которой:

- Существуют объекты разных типов, каждый из которых получает входные данные в своём формате и по‑своему их обрабатывает.
- Все эти классы реализуют общий интерфейс (набор одинаково названных методов), чтобы их можно было обрабатывать единым кодом через базовый тип.
- Программа принимает произвольное количество таких объектов (данных разных форматов), сохраняет их во внутреннюю коллекцию, а затем по команде пользователя выполняет над ними общие операции (агрегирование, поиск, фильтрацию и т.п.).

***

## Вариант 1. Геометрические фигуры разных форматов задания

### Что нужно сделать

- Спроектировать базовый интерфейс для геометрических фигур (общие методы: площадь, периметр, количество углов и т.п.).
- Описать несколько типов фигур, каждая из которых задаётся своим набором входных параметров.
- Обеспечить единый способ хранения и обработки фигур разных типов через общий интерфейс.
- Реализовать режим работы, когда пользователь вводит произвольное количество фигур разных типов, а затем выбирает, какую агрегированную характеристику посчитать (общая площадь, суммарный периметр, суммарное количество углов).


### Входные данные

- Последовательность описаний фигур, где указывается тип фигуры и её параметры, например:
    - «triangle 0 0  1 0  0 1» — треугольник по трём точкам;
    - «rectangle 0 0  3 2» — прямоугольник по двум противоположным вершинам;
    - «circle 1 1  5» — круг по центру и радиусу;
    - при желании — «polygon 0 0  5 10» — правильный многоугольник по центру, радиусу и числу вершин.
- Команда пользователя, определяющая, что нужно вывести:
    - например, «area» — общая площадь всех фигур;
    - «perimeter» — суммарный периметр;
    - «vertices» — суммарное число углов.


### Ожидаемый вывод

- Одно или несколько числовых значений в зависимости от команды, например:
    - «Total area: 123.45»
    - «Total perimeter: 57.8»
    - «Total vertices: 12»
- При наличии некорректного ввода — сообщения об ошибке в корректной форме (без падения программы).

***

## Вариант 2. Временные интервалы в разных форматах

### Что нужно сделать

- Спроектировать общий интерфейс для временных интервалов (например, метод для получения длительности в секундах и метод для человекочитаемого форматирования).
- Реализовать несколько классов, каждый из которых представляет интервал, заданный в своём формате (часы:минуты:секунды, минуты и секунды, миллисекунды и т.д.).
- Обеспечить возможность собирать разные интервалы в один список и считать по ним суммарные/средние значения через общий интерфейс.


### Входные данные

- Набор временных интервалов в разных форматах, например:
    - «hms 01:30:00» — 1 час 30 минут;
    - «ms 90000» — 90000 миллисекунд;
    - «minsec 3 45» — 3 минуты 45 секунд;
    - «hours 2.5» — 2.5 часа.
- Команда, что нужно посчитать:
    - «sum» — сумму всех интервалов;
    - «avg» — среднее значение;
    - «max» / «min» — максимальный или минимальный интервал.


### Ожидаемый вывод

- Результирующий интервал(ы) в нормализованном человекочитаемом формате, например:
    - «Total: 2 h 15 min 30 s»
    - «Average: 0 h 30 min 0 s»
    - «Max: 1 h 30 min 0 s»
- При необходимости — представление результата одновременно и в секундах, и в формате чч:мм:сс.

***

## Вариант 3 Денежные суммы разных форматов, единый ввод курсов

### Что нужно сделать

- Спроектировать общий интерфейс для денежной суммы (получение значения в базовой валюте и человекочитаемый вывод).
- Реализовать несколько классов, каждый из которых представляет сумму, заданную **в своём формате**, но использует одну и ту же таблицу курсов валют.
- Курсы валют задаются **однократно в начале работы программы** единообразным способом и далее используются всеми объектами.
- Обеспечить возможность собирать суммы разных форматов в одну коллекцию и выполнять над ними общие операции: суммирование, поиск максимальной/минимальной суммы, сортировку.


### Входные данные

1. В начале работы — **единый ввод курсов валют** в базовую валюту, например:
    - базовая валюта: `RUB`;
    - далее строки вида:
        - `USD 92.5`
        - `EUR 100.0`
        - `CNY 12.3`
где каждая строка означает: `1 <ВАЛЮТА> = X <БАЗОВАЯ>` (например, `1 USD = 92.5 RUB`).
2. Затем — **набор сумм в разных форматах**, например:
    - `code 1000 RUB` — сумма и код валюты;
    - `code 15.5 USD` — сумма в долларах;
    - `json {"amount": 200, "currency": "EUR"}` — сумма в JSON/словари;
    - `local 1 000,50 ₽` — локализованная строка с разделителями;
    - `default 500` — сумма без указания валюты (интерпретируется как базовая валюта).
3. Команда пользователя, определяющая операцию, например:
    - `sum` — общая сумма в базовой валюте;
    - `max` — максимальная сумма (с выводом как в исходной валюте, так и в базовой);
    - `min` — минимальная сумма;
    - `list` — список всех сумм в нормализованном виде.

### Ожидаемый вывод

- Для команды `sum`:
    - строка вида `Total: 25630.75 RUB` — общая сумма в базовой валюте.
- Для `max` / `min`:
    - строка вида `Max: 1500.00 USD = 138750.00 RUB`.
- Для `list`:
    - перечень всех сумм в едином формате, например:
        - `1000.00 RUB`
        - `15.50 USD = 1433.75 RUB`
        - `200.00 EUR = 20000.00 RUB`
- В случае некорректной суммы или неизвестной валюты — понятное сообщение об ошибке (без аварийного завершения программы).

## Вариант 4. Лог‑записи разных форматов

### Что нужно сделать

- Описать общий интерфейс лог‑записи (уровень, время, текст сообщения).
- Реализовать несколько классов для разных форматов логов (разные шаблоны строк, JSON).
- Обеспечить возможность совместной обработки логов разных форматов через единый интерфейс: фильтрация по уровню, поиск по времени, подсчёт статистики.


### Входные данные

- Набор строк/записей логов различного формата, например:
    - «fmt1 [2025-10-01 12:34:56] INFO: System started»
    - «fmt2 ERROR;2025/10/01-12:35;Disk full»
    - «json {"level": "WARNING", "time": "2025-10-01T12:36:00", "msg": "High load"}»
- Команды пользователя для обработки, например:
    - «count level=ERROR» — количество ошибок;
    - «range 2025-10-01 12:30 2025-10-01 13:00» — все записи за указанный промежуток;
    - «list level=WARNING» — вывод всех предупреждений.


### Ожидаемый вывод

- Статистика по логам (количество по уровням, временные диапазоны).
- Списки нормализованных записей в едином виде, например:
    - «[2025-10-01 12:35:00] ERROR Disk full»
- Сообщения об ошибках для некорректных строк, если они не поддаются разбору.

***

## Вариант 5. Пользователи из разных источников

### Что нужно сделать

- Спроектировать общий интерфейс сущности «пользователь» (идентификатор, ФИО/полное имя, email).
- Реализовать несколько классов, каждый из которых описывает пользователя, пришедшего из своего формата/источника.
- Обеспечить возможность построить единую коллекцию пользователей и выполнять по ней поиск, фильтрацию и вывод контактной информации.


### Входные данные

- Разнородные записи о пользователях, например:
    - «csv 123;Иван Иванов;ivan@example.com»
    - «json {"uid": 42, "first_name": "Petr", "last_name": "Petrov", "contacts": {"email": "petr@example.com"}}»
    - «raw Иванов Иван [ivanov@example.com](mailto:ivanov@example.com)»
- Команды, задающие операции:
    - «emails» — вывести все email‑адреса;
    - «find name=Иван» — найти всех пользователей, в имени которых встречается «Иван»;
    - «invalid» — показать записи с некорректным email.


### Ожидаемый вывод

- Списки пользователей в нормализованном формате, например:
    - « Иван Иванов [ivan@example.com](mailto:ivan@example.com)»
    - « Petr Petrov [petr@example.com](mailto:petr@example.com)»
- Отчёт о найденных/ненайденных пользователях, статистика валидности email‑ов.

***


## Вариант 6. Задачи/тикеты: разные форматы ввода

### Что нужно сделать

- Спроектировать общий интерфейс для задач/тикетов (методы для получения идентификатора, заголовка, статуса, приоритета).
- Реализовать несколько классов для разных типов задач, каждая с **собственным форматом ввода** (разные схемы полей/строк/JSON).
- Обеспечить возможность собирать любые задачи в одну коллекцию базового типа и выполнять по ним общие операции: фильтрацию по статусу, сортировку по приоритету, поиск по тексту.


### Входные данные

1. Набор описаний задач в разных форматах, например:

- Формат 1 — «bug» (строка с разделителями):
    - `bug BUG-101;Неверный расчёт налога;critical;open`
где:
    - `BUG-101` — идентификатор,
    - `Неверный расчёт налога` — краткое описание,
    - `critical` — уровень серьёзности → приоритет,
    - `open` — статус.
- Формат 2 — «feature» (JSON/псевдо‑JSON):
    - `feature {"id": "F-202", "title": "Добавить тёмную тему", "story_points": 5, "status": "in_progress"}`
где:
    - `id` — идентификатор,
    - `title` — заголовок,
    - `story_points` — числовой приоритет,
    - `status` — статус.
- Формат 3 — «support» (другой вид строки):
    - `support T-303|Проблемы со входом|high|closed`
где:
    - `T-303` — идентификатор,
    - `Проблемы со входом` — описание,
    - `high` — приоритет,
    - `closed` — статус.

2. Команды пользователя, задающие операции, например:

- `list open` — вывести все задачи в статусе «open» (или аналогично для других статусов).
- `top 3` — вывести три задачи с наивысшим приоритетом, вне зависимости от исходного формата.
- `search login` — вывести задачи, в названии/описании которых встречается указанная подстрока.


### Ожидаемый вывод

- Для `list open`:
    - перечень задач в **едином нормализованном формате**, например:
        - `[BUG-101] (critical, open) Неверный расчёт налога`
        - `[T-303] (high, open) Проблемы со входом`
- Для `top 3`:
    - список задач с максимальным приоритетом, отсортированный по убыванию приоритета, в одном формате, например:
        - `[BUG-101] (priority=10, open) Неверный расчёт налога`
        - `[F-202] (priority=5, in_progress) Добавить тёмную тему`
- Для `search login`:
    - все задачи, в которых в заголовке/описании найдено указанное слово, или сообщение, что задач не найдено.
- При некорректном формате входной строки или невозможности разбора — сообщение об ошибке с указанием проблемной записи (например, «Ошибка разбора задачи в строке N»).
